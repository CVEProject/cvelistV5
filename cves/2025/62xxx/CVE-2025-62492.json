{
    "dataType": "CVE_RECORD",
    "dataVersion": "5.1",
    "cveMetadata": {
        "cveId": "CVE-2025-62492",
        "assignerOrgId": "14ed7db2-1595-443d-9d34-6215bf890778",
        "state": "PUBLISHED",
        "assignerShortName": "Google",
        "dateReserved": "2025-10-15T08:47:41.878Z",
        "datePublished": "2025-10-16T15:51:34.445Z",
        "dateUpdated": "2025-10-16T15:51:34.445Z"
    },
    "containers": {
        "cna": {
            "affected": [
                {
                    "collectionURL": "https://bellard.org/quickjs/",
                    "defaultStatus": "unaffected",
                    "packageName": "js_typed_array_indexOf",
                    "product": "QuickJS",
                    "vendor": "QuickJS",
                    "versions": [
                        {
                            "lessThan": "2025-09-13",
                            "status": "affected",
                            "version": "2025-04-26",
                            "versionType": "date"
                        }
                    ]
                }
            ],
            "credits": [
                {
                    "lang": "en",
                    "type": "finder",
                    "value": "Google Big Sleep"
                }
            ],
            "datePublic": "2025-07-24T22:00:00.000Z",
            "descriptions": [
                {
                    "lang": "en",
                    "supportingMedia": [
                        {
                            "base64": false,
                            "type": "text/html",
                            "value": "<p>A vulnerability stemming from floating-point arithmetic precision errors exists in the QuickJS engine's implementation of <code>TypedArray.prototype.indexOf()</code> when a negative <b><code>fromIndex</code></b> argument is supplied.</p><ol><li><p>The <code>fromIndex</code> argument (read as a <code>double</code> variable, $d$) is used to calculate the starting position for the search.</p></li><li><p>If d is negative, the index is calculated relative to the end of the array by adding the array's length (len) to d:</p><p></p><div>$$d_{new} = d + \\text{len}$$</div></li><li><p>Due to the inherent limitations of <b>floating-point arithmetic</b>, if the negative value $d$ is extremely small (e.g., $-1 \\times 10^{-20}$), the addition $d + \\text{len}$ can result in a loss of precision, yielding an outcome that is <b>exactly equal to $\\text{len}$</b>.</p></li><li><p>The result is then converted to an integer index $k$: $k = \\text{len}$.</p></li><li><p>The search function proceeds to read array elements starting from index $k$. Since valid indices are $0$ to $\\text{len}-1$, starting the read at index $\\text{len}$ is <b>one element past the end of the array</b>.</p></li></ol>This allows an attacker to cause an <b>Out-of-Bounds Read</b> of one element immediately following the buffer. While the scope of this read is small (one element), it can potentially lead to <b>Information Disclosure</b> of adjacent memory contents, depending on the execution environment.<br>"
                        }
                    ],
                    "value": "A vulnerability stemming from floating-point arithmetic precision errors exists in the QuickJS engine's implementation of TypedArray.prototype.indexOf() when a negative fromIndex argument is supplied.\n\n  *  The fromIndex argument (read as a double variable, $d$) is used to calculate the starting position for the search.\n\n\n  *  If d is negative, the index is calculated relative to the end of the array by adding the array's length (len) to d:\n\n\n\n$$d_{new} = d + \\text{len}$$\n\n\n  *  Due to the inherent limitations of floating-point arithmetic, if the negative value $d$ is extremely small (e.g., $-1 \\times 10^{-20}$), the addition $d + \\text{len}$ can result in a loss of precision, yielding an outcome that is exactly equal to $\\text{len}$.\n\n\n  *  The result is then converted to an integer index $k$: $k = \\text{len}$.\n\n\n  *  The search function proceeds to read array elements starting from index $k$. Since valid indices are $0$ to $\\text{len}-1$, starting the read at index $\\text{len}$ is one element past the end of the array.\n\n\nThis allows an attacker to cause an Out-of-Bounds Read of one element immediately following the buffer. While the scope of this read is small (one element), it can potentially lead to Information Disclosure of adjacent memory contents, depending on the execution environment."
                }
            ],
            "impacts": [
                {
                    "capecId": "CAPEC-175",
                    "descriptions": [
                        {
                            "lang": "en",
                            "value": "CAPEC-175 Code Inclusion"
                        }
                    ]
                }
            ],
            "metrics": [
                {
                    "cvssV4_0": {
                        "Automatable": "NOT_DEFINED",
                        "Recovery": "NOT_DEFINED",
                        "Safety": "NOT_DEFINED",
                        "attackComplexity": "HIGH",
                        "attackRequirements": "PRESENT",
                        "attackVector": "ADJACENT",
                        "baseScore": 5.9,
                        "baseSeverity": "MEDIUM",
                        "privilegesRequired": "LOW",
                        "providerUrgency": "NOT_DEFINED",
                        "subAvailabilityImpact": "LOW",
                        "subConfidentialityImpact": "HIGH",
                        "subIntegrityImpact": "LOW",
                        "userInteraction": "PASSIVE",
                        "valueDensity": "NOT_DEFINED",
                        "vectorString": "CVSS:4.0/AV:A/AC:H/AT:P/PR:L/UI:P/VC:H/VI:L/VA:L/SC:H/SI:L/SA:L",
                        "version": "4.0",
                        "vulnAvailabilityImpact": "LOW",
                        "vulnConfidentialityImpact": "HIGH",
                        "vulnIntegrityImpact": "LOW",
                        "vulnerabilityResponseEffort": "NOT_DEFINED"
                    },
                    "format": "CVSS",
                    "scenarios": [
                        {
                            "lang": "en",
                            "value": "GENERAL"
                        }
                    ]
                }
            ],
            "problemTypes": [
                {
                    "descriptions": [
                        {
                            "cweId": "CWE-125",
                            "description": "CWE-125 Out-of-bounds Read",
                            "lang": "en",
                            "type": "CWE"
                        }
                    ]
                }
            ],
            "providerMetadata": {
                "orgId": "14ed7db2-1595-443d-9d34-6215bf890778",
                "shortName": "Google",
                "dateUpdated": "2025-10-16T15:51:34.445Z"
            },
            "references": [
                {
                    "url": "https://bellard.org/quickjs/Changelog"
                },
                {
                    "url": "https://issuetracker.google.com/434194797"
                }
            ],
            "source": {
                "discovery": "UNKNOWN"
            },
            "title": "Heap out-of-bounds read in js_typed_array_indexOf in QuickJS",
            "x_generator": {
                "engine": "Vulnogram 0.2.0"
            }
        }
    }
}