{
    "dataType": "CVE_RECORD",
    "dataVersion": "5.1",
    "cveMetadata": {
        "cveId": "CVE-2025-59734",
        "assignerOrgId": "14ed7db2-1595-443d-9d34-6215bf890778",
        "state": "PUBLISHED",
        "assignerShortName": "Google",
        "dateReserved": "2025-09-19T08:11:37.550Z",
        "datePublished": "2025-10-06T08:09:44.280Z",
        "dateUpdated": "2025-10-19T14:51:43.143Z"
    },
    "containers": {
        "cna": {
            "affected": [
                {
                    "collectionURL": "https://git.ffmpeg.org/ffmpeg.git",
                    "defaultStatus": "unaffected",
                    "packageName": "SANM",
                    "product": "FFmpeg",
                    "repo": "https://git.ffmpeg.org/ffmpeg.git",
                    "vendor": "FFmpeg",
                    "versions": [
                        {
                            "lessThan": "8.0",
                            "status": "affected",
                            "version": "4d7c609be37dc57d31527c8c9e5945dc9491a7cd",
                            "versionType": "custom"
                        },
                        {
                            "lessThan": "8.0",
                            "status": "affected",
                            "version": "7.1.1",
                            "versionType": "semver"
                        }
                    ]
                }
            ],
            "credits": [
                {
                    "lang": "en",
                    "type": "finder",
                    "value": "Google Big Sleep"
                }
            ],
            "datePublic": "2025-08-20T22:00:00.000Z",
            "descriptions": [
                {
                    "lang": "en",
                    "supportingMedia": [
                        {
                            "base64": false,
                            "type": "text/html",
                            "value": "<p></p><p></p><p></p><p></p><p></p><p>It is possible to cause an use-after-free write in SANM decoding with a carefully crafted animation using subversion &lt;2.</p><p>When a <code>STOR</code>&nbsp;chunk is present, a subsequent <code>FOBJ</code>&nbsp;chunk will be saved in <code>ctx-&gt;stored_frame</code>. Stored frames can later be referenced by <code>FTCH</code>&nbsp;chunks. For files using subversion &lt; 2, the undecoded frame is stored, and decoded again when the <code>FTCH</code>&nbsp;chunks are parsed.&nbsp;<span style=\"background-color: rgb(255, 255, 255);\">However, in </span><code>process_frame_obj</code><span style=\"background-color: rgb(255, 255, 255);\">&nbsp;if the frame has an invalid size, there’s an early return, with a value of 0.&nbsp;</span></p><p>This causes the code in <code>decode_frame</code>&nbsp;to still store the raw frame buffer into <code>ctx-&gt;stored_frame</code>. Leaving <code>ctx-&gt;has_dimensions</code>&nbsp;set to <code>false</code>.</p><p>A subsequent chunk with type <code>FTCH</code>&nbsp;would call <code>process_ftch</code>&nbsp;and decode that frame obj again, adding to the top/left values and calling <code>process_frame_obj</code>&nbsp;again.<br><span style=\"background-color: rgb(255, 255, 255);\">Given that we never set </span><code>ctx-&gt;have_dimensions</code><span style=\"background-color: rgb(255, 255, 255);\">&nbsp;before, this time we set the dimensions, calling </span><code>init_buffers</code><span style=\"background-color: rgb(255, 255, 255);\">, which can reallocate the buffer in </span><code>ctx-&gt;stored_frame</code><span style=\"background-color: rgb(255, 255, 255);\">, freeing the previous one. However, the </span><code>GetByteContext</code><span style=\"background-color: rgb(255, 255, 255);\">&nbsp;object </span><code>gb</code><span style=\"background-color: rgb(255, 255, 255);\">&nbsp;still holds a reference to the old buffer.</span><br></p><p></p><p>Finally, when the code tries to decode the frame, codecs that accept a <code>GetByteContext</code>&nbsp;as a parameter will trigger a use-after-free read when using <code>gb</code>.</p><p><code>GetByteContext</code>&nbsp;is only used for reading bytes, so at most one could read invalid data. There are no heap allocations between the <code>free</code>&nbsp;and when the object is accessed. However, upon returning to <code>process_ftch</code>, the code <em>restores</em>&nbsp;the original values for top/left in <code>stored_frame</code>, writing 4 bytes to the freed data at offset 6, potentially corrupting the allocator’s metadata.</p><p>This issue can be triggered just by probing whether a file has the sanm format.</p><p></p><p></p><p></p>We recommend upgrading to version 8.0 or beyond.<p></p><br>"
                        }
                    ],
                    "value": "It is possible to cause an use-after-free write in SANM decoding with a carefully crafted animation using subversion <2.\n\nWhen a STOR chunk is present, a subsequent FOBJ chunk will be saved in ctx->stored_frame. Stored frames can later be referenced by FTCH chunks. For files using subversion < 2, the undecoded frame is stored, and decoded again when the FTCH chunks are parsed. However, in process_frame_obj if the frame has an invalid size, there’s an early return, with a value of 0. \n\nThis causes the code in decode_frame to still store the raw frame buffer into ctx->stored_frame. Leaving ctx->has_dimensions set to false.\n\nA subsequent chunk with type FTCH would call process_ftch and decode that frame obj again, adding to the top/left values and calling process_frame_obj again.\nGiven that we never set ctx->have_dimensions before, this time we set the dimensions, calling init_buffers, which can reallocate the buffer in ctx->stored_frame, freeing the previous one. However, the GetByteContext object gb still holds a reference to the old buffer.\n\n\n\n\nFinally, when the code tries to decode the frame, codecs that accept a GetByteContext as a parameter will trigger a use-after-free read when using gb.\n\nGetByteContext is only used for reading bytes, so at most one could read invalid data. There are no heap allocations between the free and when the object is accessed. However, upon returning to process_ftch, the code restores the original values for top/left in stored_frame, writing 4 bytes to the freed data at offset 6, potentially corrupting the allocator’s metadata.\n\nThis issue can be triggered just by probing whether a file has the sanm format.\n\n\n\n\n\n\n\nWe recommend upgrading to version 8.0 or beyond."
                }
            ],
            "impacts": [
                {
                    "capecId": "CAPEC-100",
                    "descriptions": [
                        {
                            "lang": "en",
                            "value": "CAPEC-100 Overflow Buffers"
                        }
                    ]
                }
            ],
            "metrics": [
                {
                    "cvssV4_0": {
                        "Automatable": "NOT_DEFINED",
                        "Recovery": "NOT_DEFINED",
                        "Safety": "NOT_DEFINED",
                        "attackComplexity": "HIGH",
                        "attackRequirements": "NONE",
                        "attackVector": "ADJACENT",
                        "baseScore": 8.7,
                        "baseSeverity": "HIGH",
                        "privilegesRequired": "NONE",
                        "providerUrgency": "NOT_DEFINED",
                        "subAvailabilityImpact": "NONE",
                        "subConfidentialityImpact": "HIGH",
                        "subIntegrityImpact": "HIGH",
                        "userInteraction": "PASSIVE",
                        "valueDensity": "NOT_DEFINED",
                        "vectorString": "CVSS:4.0/AV:A/AC:H/AT:N/PR:N/UI:P/VC:H/VI:H/VA:N/SC:H/SI:H/SA:N",
                        "version": "4.0",
                        "vulnAvailabilityImpact": "NONE",
                        "vulnConfidentialityImpact": "HIGH",
                        "vulnIntegrityImpact": "HIGH",
                        "vulnerabilityResponseEffort": "NOT_DEFINED"
                    },
                    "format": "CVSS",
                    "scenarios": [
                        {
                            "lang": "en",
                            "value": "GENERAL"
                        }
                    ]
                }
            ],
            "problemTypes": [
                {
                    "descriptions": [
                        {
                            "cweId": "CWE-416",
                            "description": "CWE-416 Use After Free",
                            "lang": "en",
                            "type": "CWE"
                        }
                    ]
                }
            ],
            "providerMetadata": {
                "orgId": "14ed7db2-1595-443d-9d34-6215bf890778",
                "shortName": "Google",
                "dateUpdated": "2025-10-19T14:51:43.143Z"
            },
            "references": [
                {
                    "url": "https://issuetracker.google.com/440183164"
                }
            ],
            "source": {
                "discovery": "EXTERNAL"
            },
            "title": "Heap-buffer-overflow write in FFmpeg SANM process_ftch",
            "x_generator": {
                "engine": "Vulnogram 0.2.0"
            }
        },
        "adp": [
            {
                "metrics": [
                    {
                        "other": {
                            "type": "ssvc",
                            "content": {
                                "timestamp": "2025-10-07T00:00:00+00:00",
                                "options": [
                                    {
                                        "Exploitation": "none"
                                    },
                                    {
                                        "Automatable": "no"
                                    },
                                    {
                                        "Technical Impact": "total"
                                    }
                                ],
                                "role": "CISA Coordinator",
                                "version": "2.0.3",
                                "id": "CVE-2025-59734"
                            }
                        }
                    }
                ],
                "title": "CISA ADP Vulnrichment",
                "providerMetadata": {
                    "orgId": "134c704f-9b21-4f2e-91b3-4a467353bcc0",
                    "shortName": "CISA-ADP",
                    "dateUpdated": "2025-10-08T03:55:14.843Z"
                }
            }
        ]
    }
}